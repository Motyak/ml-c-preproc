#pragma once

#include <std/fn/Stream.mlp>
#include <std/fn/loops.mlp>
#include <std/fn/curry.mlp>
#include <std/fn/delay.mlp>

var foreach (OUT subscriptable, fn):{
    var foreach (OUT container, fn):{
        tern(len(container) == 0, container, {
            var nth 1
            until(():{nth > len(container)}, ():{
                fn(&container[#nth])
                nth += 1
            })
            container
        })
    }

    var Stream::foreach (stream, fn):{
        var foreach_rec _
        foreach_rec := (stream, fn):{
            tern(none?(stream), END, {
                fn(left(some(stream)))
                foreach_rec(right(some(stream)), fn)
            })
        }
        foreach_rec(stream, fn)
        stream
    }

    var is_lambda (x):{
        Str(x) == "<lambda>"
    }

    !tern(is_lambda(subscriptable), foreach(&subscriptable, fn), {
        Stream::foreach(&subscriptable, fn)
    })
}

var foreach' {
    var foreach' (fn, container):{
        foreach(container, fn)
    }

    curry(foreach')
}

var map {
    var map (fn, subscriptable):{
        var map (fn, container):{
            var res container
            foreach(1 .. len(res), (nth):{
                res[#nth] := fn(res[#nth])
            })
            res
        }

        var Stream::map _
        Stream::map := (fn, stream):{
            tern(none?(stream), END, {
                var curr fn(left(some(stream)))
                var next delay(Stream::map(fn, right(some(stream))))
                Pair?(curr, next())
            })
        }

        var is_lambda (x):{
            Str(x) == "<lambda>"
        }

        !tern(is_lambda(subscriptable), map(fn, subscriptable), {
            Stream::map(fn, subscriptable)
        })
    }


    curry(map)
}

var filter {
    var filter (pred, subscriptable):{
        var filter (pred, container):{
            var is_list (x):{
                var str Str(x)
                len(str) > 0 && str[#1] == "[" && str[#-1] == "]"
            }

            var res tern(is_list(container), [], "")
            foreach(1 .. len(container), (nth):{
                pred(container[#nth]) && {
                    is_list(container) && {res += [container[#nth]]}
                    is_list(container) || {res += container[#nth]}
                }
            })
            res
        }

        var Stream::filter _
        Stream::filter := (pred, stream):{
            tern(none?(stream), END, {
                var curr left(some(stream))
                var next delay(Stream::filter(pred, right(some(stream))))
                !tern(pred(curr), next(), {
                    Pair?(curr, next())
                })
            })
        }

        var is_lambda (x):{
            Str(x) == "<lambda>"
        }

        !tern(is_lambda(subscriptable), filter(pred, subscriptable), {
            Stream::filter(pred, subscriptable)
        })
    }

    curry(filter)
}

var reduce {
    var reduce (fn, acc, subscriptable):{
        foreach(subscriptable, (curr):{
            acc := fn(acc, curr)
        })
        acc
    }
    curry(reduce)
}

var split {
    var split (sep, str):{
        var res []
        var curr ""
        foreach(str, (c):{
            !tern(c == sep, {curr += c}, {
                res += [curr]
                curr := ""
            })
        })
        len(curr) > 0 && {res += [curr]}
        res
    }
    curry(split)
}

var join {
    var join (sep, container):{
        var res ""
        var first_it $true
        foreach(container, (str):{
            first_it || {res += sep}
            res += str
            first_it := $false
        })
        res
    }
    curry(join)
}

var count {
    var count (pred, subscriptable):{
        var fn (lhs, rhs):{
            tern(pred(rhs), lhs + 1, lhs)
        }
        reduce(fn, 0, subscriptable)
    }
    curry(count)
}

var min (a, b, others...):{
    var < (lhs, rhs):{
        not(lhs > rhs || lhs == rhs)
    }
    var min (lhs, rhs):{
        tern(lhs < rhs, lhs, rhs)
    }
    reduce(min, a, List(b, others...))
}

var min' {
    var min' (subscriptable):{
        var < (lhs, rhs):{
            not(lhs > rhs || lhs == rhs)
        }
        var min2 (lhs, rhs):{
            tern(lhs < rhs, lhs, rhs)
        }
        var min (container):{
            tern(len(container) == 0, ERR("empty container"), {
                tern(len(container) == 1, container[#1], {
                    reduce(min2, container[#1], container[#2..-1])
                })
            })
        }
        var Stream::min (stream):{
            tern(none?(stream), ERR("empty stream"), {
                reduce(min2, left(some(stream)), right(some(stream)))
            })
        }

        var is_lambda (x):{
            Str(x) == "<lambda>"
        }

        !tern(is_lambda(subscriptable), min(subscriptable), {
            Stream::min(subscriptable)
        })
    }
    curry(min')
}

var max (a, b, others...):{
    var max (lhs, rhs):{
        tern(lhs > rhs, lhs, rhs)
    }
    reduce(max, a, List(b, others...))
}

var max' {
    var max' (subscriptable):{
        var max2 (lhs, rhs):{
            tern(lhs > rhs, lhs, rhs)
        }
        var max (container):{
            tern(len(container) == 0, ERR("empty container"), {
                tern(len(container) == 1, container[#1], {
                    reduce(max2, container[#1], container[#2..-1])
                })
            })
        }
        var Stream::max (stream):{
            tern(none?(stream), ERR("empty stream"), {
                reduce(max2, left(some(stream)), right(some(stream)))
            })
        }

        var is_lambda (x):{
            Str(x) == "<lambda>"
        }

        !tern(is_lambda(subscriptable), max(subscriptable), {
            Stream::max(subscriptable)
        })
    }
    curry(max')
}

package main

"=== testing foreach ==="

var id (x):{
    print("evaluated: " + x)
    x
}

var |> (input, fn):{
    fn(input)
}

{
    var str "fds"
    var list [1, 2, 3]
    var stream LazyList(1, id(2), 3)

    foreach(&str, (OUT c):{c := 'x})
    print(str)
    var newstr foreach(str, (OUT c):{c := 'y})
    print(str)
    print(newstr)

    foreach(&list, (OUT n):{n := 0})
    print(list)
    var newlist foreach(list, (OUT n):{n := 7})
    print(list)
    print(newlist)

    foreach(stream, (x):{print(x)})
    stream |> foreach'((x):{print(x)})
}

"test curryable foreach"

{
    var ascii (c):{
        Int(Char(c))
    }

    var upper (OUT c):{
        var - (lhs, rhs):{
            lhs + rhs + -2 * rhs
        }

        c := Char(c) - (ascii('a) - ascii('A))
    }

    var str "fds"

    print(str |> foreach'(upper))
}

"=== testing filter/reduce on LazyRange ==="

var ERR (msg):{
    print("ERR: " + msg)
    exit(1)
}

var <= (lhs, rhs):{
    not(lhs > rhs)
}

var - (lhs, rhs):{
    lhs + rhs + -2 * rhs
}

var ascii (c):{
    Int(Char(c))
}

var sumOfDigits (n):{
    n := Str(n)
    var res 0
    foreach(n, (c):{
        ascii('0) <= c && c <= ascii('9) || ERR("not a number")
        res += ascii(c) - ascii('0)
    })
    res
}

-- mod 10 not equal zero
var %10<>0 (n):{
    var <> (lhs, rhs):{
        not(lhs == rhs)
    }

    Str(n)[#-1] <> '0
}

var predicate (n):{
    var < (lhs, rhs):{
        not(lhs > rhs || lhs == rhs)
    }

    %10<>0(n) && sumOfDigits(n) < 10
}

var fn (n):{
    n * 11 * 999
}

var seq LazyRange<=(1, 90)
-- foreach(seq, print)

seq := seq |> filter(predicate)
-- foreach(seq, print)

seq := seq |> map(fn)
-- foreach(seq, print)

"=== testing map/filter ==="

var .. LazyRange<=

{
    var seq [1, 2, 3, 4, 5]
    seq := seq |> map((n):{2 * n})
    seq := seq |> filter((n):{n > 4})
    _ := seq |> foreach'(curry_fixed(1, print))
}

{
    var seq 1 .. 10
    seq := seq |> map((n):{2 * n})
    seq := seq |> filter((n):{n > 4})
    _ := seq |> foreach'(curry_fixed(1, print))
}

"=== testing reduce ==="

reduce(+, 0, [1, 2, 3]) |> stdout
reduce(+, 'T, "ommy") |> stdout

1 .. 5 |> reduce(+, 0) |> stdout

var ab'cd'ef [14, 28, 57]
var abc'def [142, 857]

print('ab'cd'ef, ab'cd'ef, ab'cd'ef |> reduce(+, 0))
print('abc'def, abc'def, abc'def |> reduce(+, 0))

var range2str (range):{
    reduce(+, "", range)
}
['0 .. '9, 'a .. 'z] |> map(range2str) |> reduce(+, "") |> stdout

"=== testing min ==="

min(1, 2, 3, 4, 5, 6) |> stdout
[1, 2, 3, 4, 5, 6] |> min' |> stdout
1 .. 10 |> min' |> stdout

"=== testing split/join ==="

var upper (OUT c):{
    var ascii (c):{
        Int(Char(c))
    }
    var <= (lhs, rhs):{
        not(lhs > rhs)
    }
    var - (lhs, rhs):{
        lhs + rhs + -2 * rhs
    }
    tern(ascii(c) <= ascii('Z), c, {
        var local_c Char(c)
        local_c -= ascii('a) - ascii('A)
        c := local_c
        local_c
    })
}

"hello" |> map(upper) |> stdout
"fds" |> join(",") |> stdout
[1, 2, 3] |> join(" ") |> stdout

"abc fds 123" |> split(" ") |> stdout

"f,d,s" |> split(",") |> map(upper) |> join("_") |> stdout

"=== testing min ==="

max(1, 2, 3, 4, 5, 6) |> stdout
[1, 2, 3, 4, 5, 6] |> max' |> stdout
1 .. 10 |> max' |> stdout

"=== testing count ==="

var is_even (n):{
    var in (elem, container):{
        var i 1
        var found $false
        until(():{found || i > len(container)}, ():{
            found ||= container[#i] == elem
            i += 1
        })
        found
    }
    Str(Int(n))[#-1] in "02468"
}

[1, 2, 3, 4, 5, 6] |> count(is_even) |> stdout
1 .. 10 |> count(is_even) |> stdout
